#include"client.h"
#include"externTools.h"
#pragma comment(lib, "ws2_32.lib")
#include<winsock2.h>
#include<WS2tcpip.h>
#include<iostream>
#include<fstream>
#include<stdio.h>
#include <io.h>
#include<mutex>
#include<time.h>
#include<processthreadsapi.h>
using namespace std;

// 一些个全局变量
static SOCKET sendSocket, recvSocket; // 前面的socket用来发送，后面的用来接收
static SOCKADDR_IN serverAddr, clientAddr;
static int socketAddrLen = sizeof(serverAddr);
static const unsigned int MAX_WAIT_TIME = 100000; // 设置最大的等待时间
static string path = "./test/*";

static double sendFileTime; // 设置一个全局变量，用来计算吞吐率，这里是时间
static double Throughput; // 吞吐率

// 流量控制
static int WINDOW_SIZE = 10; // 设置最大的窗口大小 此次没有用到

// 三次握手的时候对应的flag
const unsigned char SHAKE1 = 0x01;
const unsigned char SHAKE2 = 0x02;
const unsigned char SHAKE3 = 0x03;
// 四次挥手的时候的flag
const unsigned char WAVE1 = 0x04;
const unsigned char WAVE2 = 0x05;
// 传输时使用的端口
const int CLIENT_PORT = 12880;
const int SERVER_PORT = 12660;
const int LUYOU_PORT = 8889;

// 拥塞控制
static unsigned int ssthresh = 16; // 初始的阈值设置为16
static unsigned int cwnd = 1; // 初始的拥塞窗口设置为1

static unsigned int sameAckTimes = 0; // 重复收到ack的数量
static int lastAck = -1; // 记录上次收到的ACK，初始的时候是-1，这样就能把0也放进来

// 计时器，当为-1的时候表示计时器停止。
static int timer = -1;
// 下一个要发送的
static int curr = 0;
static int stop = 0;
/*
拥塞控制相关算法：
	1. 当cwnd < ssthresh,使用慢启动算法，
	2. 当cwnd > ssthresh,使用拥塞避免算法，停用慢启动算法。
	3. 当cwnd = ssthresh，这两个算法都可以。
慢启动算法：1-2-4-8-……
拥塞避免算法：1-2-3-4-……
*/


/* 
要发送的数据包的样子
data[1024]
check, seq[3], len[2],isLast, data[1017]
0      1-3     4-5    6       7-1023
发送的第一个包是名称的长度

接收方返回的数据包的样子
ans[4]
check, ack[3]
0      1-3  

协议使用：GBN
SR
*/
static int dataLen = 1017; // 设置每个数据包中的最大数据长度

HANDLE hMutex = CreateMutex(NULL, FALSE, L"GLOBAL\\curr");

struct communicate_data {
	int totalNum;		//总共有n个包
	char** sendPackage;	//包体
	communicate_data(int num) :totalNum(num) {
		sendPackage = new char* [num];
		for (int i = 0; i < num; i++)
			sendPackage[i] = new char[1024];
	}
};

/// <summary>
/// 停等机制向服务器握手
/// </summary>
void connet2Server() {
	// 三次握手，建立连接
	// 创建一个要发送的数据包，并初始化为空
	//Package connectPackage;
	//memset(&connectPackage, 0, sizeof(connectPackage));
	
	// 数据包：check, SYN，FIN，SHAKE/WAVE
	char shakeChar[4];
	shakeChar[1] = 0x01;
	shakeChar[2] = 0x00;
	shakeChar[3] = SHAKE1;
	shakeChar[0] = newGetChecksum(shakeChar+1, 3);

	// 发送shake1
	sendto(sendSocket, shakeChar, 4, 0, (SOCKADDR*)&serverAddr, socketAddrLen);
	cout<< "开始建立连接，请求建立连接的数据包为（第一次握手）：\n";
	cout << "SYN: " << int(shakeChar[1]) << "\tFIN: " << int(shakeChar[2]) << "\tSHAKE: " << int(shakeChar[3]) << "\tcheckSum: " << int(shakeChar[0]) << "\n";

	int beginTime = clock();
	//cout << int(newGetChecksum(shakeChar, 4));

	char recvShakeBuf[4];
	memset(recvShakeBuf, 0, 4);

	while((recvfrom(sendSocket, recvShakeBuf, 4, 0, (SOCKADDR*)&serverAddr, &socketAddrLen))==SOCKET_ERROR){
		if (clock() - beginTime > MAX_WAIT_TIME) {
			cout << "超过最长等待时间，重传:";
			sendto(sendSocket, shakeChar, 4, 0, (SOCKADDR*)&serverAddr, socketAddrLen);
			beginTime = clock();
			cout << "SYN: " << int(shakeChar[1]) << "\tFIN: " << int(shakeChar[2]) << "\tSHAKE: " << int(shakeChar[3]) << "\tcheckSum: " << int(shakeChar[0]) << "\n";
		}
	}
	// 收到数据包
	cout << "收到数据包为：\n";
	cout << "SYN: " << int(recvShakeBuf[1]) << "\tFIN: " << int(recvShakeBuf[2]) << "\tSHAKE: " << int(recvShakeBuf[3]) << "\tcheckSum: " << int(recvShakeBuf[0]) << "\n";

	if (newGetChecksum(recvShakeBuf, 4)==0 && recvShakeBuf[1] == 0x01 && recvShakeBuf[2] == 0x00 && recvShakeBuf[3] == SHAKE2) {
		// 收到握手包正确
		// 发送第三次握手包的内容
		memset(shakeChar, 0, 4);
		shakeChar[1] = 0x01;
		shakeChar[2] = 0x00;
		shakeChar[3] = SHAKE3;
		shakeChar[0] = newGetChecksum(shakeChar+1, 3);
		sendto(sendSocket, shakeChar, 4, 0, (SOCKADDR*)&serverAddr, socketAddrLen);
		cout << "发送第三次握手数据包：\n";
		cout << "SYN: " << int(shakeChar[1]) << "\tFIN: " << int(shakeChar[2]) << "\tSHAKE: " << int(shakeChar[3]) << "\tcheckSum: " << int(shakeChar[0]) << "\n";
			
		cout << "\n连接建立成功!\n\n";
	}
}

DWORD WINAPI sendMessage(LPVOID Lparam) {
	communicate_data* commu_data;
	commu_data = (communicate_data*)Lparam;
	WaitForSingleObject(hMutex, INFINITE);
	stop = lastAck + cwnd + 1;
	if (curr >= stop)
		curr = lastAck + 1;
	//curr = lastAck + 1;
	cout << "start:" << curr << "\tstop: " << stop << "\n";
	if (lastAck == (curr - 1)) {
		// 表示此时之前的都已经收到了，拥塞控制的窗口发生变化
		if (lastAck != -1) {
			// 判断此时是用慢启动还是用拥塞避免
			if (cwnd < ssthresh)
				// 此时是慢启动，直接翻倍
				cwnd *= 2;
			else
				// 此时使用拥塞避免
				cwnd += 1;
		}
	}
	int tempCal = 0;
	//for (tempCal; (tempCal < cwnd) && (curr < commu_data->totalNum) && (curr < stop); tempCal++) {
	for (tempCal; (tempCal < cwnd) && (curr < commu_data->totalNum) && (curr < stop); tempCal++) {
		// 发送数据包
		sendto(sendSocket, (char*)commu_data->sendPackage[curr], 1024, 0, (SOCKADDR*)&serverAddr, socketAddrLen);
		if (tempCal == (cwnd - 1) || curr == (commu_data->totalNum - 1))
			// 计时器开始计时
			timer = clock();
		// 输出相关信息
		cout << "当前发送数据包为：\nseq: " << curr << "\nlen高: " << int(commu_data->sendPackage[curr][4]) << "\tlen低: " << int(commu_data->sendPackage[curr][5])
			<< "\tchecksum: " << int(commu_data->sendPackage[curr][0]) << "\n" << "ssthresh：" << ssthresh << "\tcwnd：" << cwnd << "\n";
		curr += 1;
	}
	ReleaseMutex(hMutex);
	return 0;
}

/// <summary>
/// 向服务器传输文件使用的函数，滑动窗口
/// </summary>
/// <param name="fileName">要传输的文件名</param>
/// <param name="fileNameLen">文件名的长度</param>
static void sendFile2Server(char* fileName, unsigned short int fileNameLen) {
	// 对输入的名字进行处理
	char filePath[] = "./test/";
	char* fileNameN = new char[7 + fileNameLen + 1];
	for (int i = 0; i < 7 + fileNameLen + 1; i++) {
		if (i < 7)
			fileNameN[i] = filePath[i];
		else
			fileNameN[i] = fileName[i - 7];
	}
	fileNameN[7 + fileNameLen + 1] = '\0';
	// cout << fileNameN << "\n";

	// 读取文件（以二进制形式读入）
	ifstream toSendFile(fileNameN, ifstream::in | ios::binary);

	// 计算文件的长度
	toSendFile.seekg(0, toSendFile.end);
	unsigned int fileLen = toSendFile.tellg();
	toSendFile.seekg(0, toSendFile.beg);
	cout << "计算得到要发送的文件长度为：" << fileLen << "\n";

	// 计算需要封装成多少个包
	unsigned int totalNum = fileLen / dataLen;
	if (fileLen % dataLen > 0)
		totalNum += 1;
	// 再加一个表示文件名称的包
	totalNum += 1;
	cout << "一共需要封装成" << totalNum << "个包\n";

	// 计时器，当为-1的时候表示计时器停止。
	int timer = -1;

	// 创建临时缓冲区
	char* tempBuf = new char[fileLen];
	// 将文件装载到缓冲区
	toSendFile.read(tempBuf, fileLen);


	// 窗口的最左边
	unsigned int leftWindow = 0; 
	// 下一个要发送的
	unsigned int curr = 0;

	//// 开始封装数据包
	// 	   将文件全部封装，以后就直接发，而不是每次发之前封装
	char** sendPackage = new char*[totalNum];
	for (int tmp = 0; tmp < totalNum; tmp++) {
		*(sendPackage + tmp) = new char[1024];
		memset(sendPackage[tmp], 0, 1024);
	}

	// 设置文件名包体的内容
	sendPackage[0][3] = 0x00;
	for (unsigned short int i = 0; i < fileNameLen; i++) {
		sendPackage[0][i + 7] = fileName[i];
	}
	sendPackage[0][5] = unsigned char(fileNameLen & 0x00FF);
	sendPackage[0][4] = unsigned char((fileNameLen >> 8) & 0x00FF);
	sendPackage[0][0] = newGetChecksum(sendPackage[0]+1, 1024-1);

	// 开始对文件整体进行打包
	for (int tmp = 1; tmp < totalNum; tmp++) {
		// 设置标志位
		sendPackage[tmp][3] = tmp & 0xFF;
		sendPackage[tmp][2] = (tmp >> 8) & 0xFF;
		sendPackage[tmp][1] = (tmp >> 16) & 0xFF;

		// 设置isLast位
		if (tmp == totalNum - 1)
			sendPackage[tmp][6] = 0x01;
		else
			sendPackage[tmp][6] = 0x00;

		// 装载下一部分文件
		unsigned short int actualLen = 0;
		for (int tempPoint = 0; (tempPoint < dataLen) && ((tmp - 1) * dataLen + tempPoint) < fileLen; tempPoint++) {
			sendPackage[tmp][7 + tempPoint] = tempBuf[(tmp - 1) * dataLen + tempPoint];
			actualLen += 1;
		}

		// 设置长度
		sendPackage[tmp][5] = unsigned char(actualLen & 0x00FF);
		sendPackage[tmp][4] = unsigned char((actualLen >> 8) & 0x00FF);

		// 计算校验和
		sendPackage[tmp][0] = newGetChecksum(sendPackage[tmp] + 1, 1024 - 1);
	}
	// ---------至此文件全部打包结束

	// 创建一个sr缓冲区，并初始化
	bool* srBuf = new bool[totalNum] ;
	for (int i = 0; i < totalNum; i++)
		srBuf[i] = false;

	communicate_data* commu_data = new communicate_data(totalNum);
	commu_data->sendPackage = sendPackage;

	// 从开始发送第一个数据包这里开始计算需要统计的时间
	sendFileTime = clock();
	int maxAckTimes = 0;
	while (lastAck != totalNum - 1) {
		cout << "curr:" << curr << "\t lastAck: " << lastAck << "\n";
		HANDLE send_thread = CreateThread(NULL, NULL, sendMessage, commu_data, NULL, NULL);
		//// 增加一个判断，只有当所有的都ack了才发
		//if (lastAck == (curr - 1)) {
		//	// 表示此时之前的都已经收到了，拥塞控制的窗口发生变化
		//	if (lastAck != -1) {
		//		// 判断此时是用慢启动还是用拥塞避免
		//		if (cwnd < ssthresh)
		//			// 此时是慢启动，直接翻倍
		//			cwnd *= 2;
		//		else
		//			// 此时使用拥塞避免
		//			cwnd += 1;
		//	}

		//	// 发cwnd个包
		//	HANDLE send_thread = CreateThread(NULL, NULL, sendMessage, commu_data, NULL, NULL);
		//	
		//	// int tempCal = 0;
		//	// for (tempCal; (tempCal < cwnd) && (curr < totalNum); tempCal++) {
		//	// 	// 发送数据包
		//	// 	sendto(sendSocket, (char*)sendPackage[curr], 1024, 0, (SOCKADDR*)&serverAddr, socketAddrLen);
		//	// 	if (curr == (cwnd - 1) || curr == (totalNum - 1))
		//	// 		// 计时器开始计时
		//	// 		timer = clock();
		//	// 	// 输出相关信息
		//	// 	cout << "当前发送数据包为：\nseq: " << curr << "\nlen高: " << int(sendPackage[curr][4]) << "\tlen低: " << int(sendPackage[curr][5])
		//	// 		<< "\tchecksum: " << int(sendPackage[curr][0]) << "\n" << "ssthresh：" << ssthresh << "\tcwnd：" << cwnd << "\n";
		//	// 	curr += 1;
		//	// }
		//}

		// 创建一个用来存放回复的消息的包，长度为4
		char recvBuf[4];

		int RecvNumInThisTurn = 0;

		while (recvfrom(sendSocket, recvBuf, 4, 0, (SOCKADDR*)&serverAddr, &socketAddrLen) == SOCKET_ERROR) {
			if (((timer != -1) && (clock() - timer > MAX_WAIT_TIME))|| maxAckTimes >= 3) {
				// 超时，需要重新进入慢启动阶段
				cout << "==================超过最长等待时间，进入到慢启动阶段:\n";
				// 拥塞控制的窗口发生变化
				ssthresh = max(cwnd / 2, 2);
				cwnd = 1;
				// 重传刚刚的包
				WaitForSingleObject(hMutex, INFINITE);
				curr = lastAck + 1;
				int tempCal = 0;
				for (tempCal; (tempCal < cwnd) && (curr < totalNum); tempCal++) {
					// 发送数据包
					sendto(sendSocket, (char*)sendPackage[curr], 1024, 0, (SOCKADDR*)&serverAddr, socketAddrLen);
					if (tempCal == (cwnd - 1) || curr == (totalNum - 1))
						// 计时器开始计时
						timer = clock();
					// 输出相关信息
					cout << "当前发送数据包为：\nseq: " << curr << "\nlen高: " << int(sendPackage[curr][4]) << "\tlen低: " << int(sendPackage[curr][5])
						<< "\tchecksum: " << int(sendPackage[curr][0]) << "\n" << "ssthresh：" << ssthresh << "\tcwnd：" << cwnd << "\n";
					curr += 1;
				}
				ReleaseMutex(hMutex);
			}
		}
		// 表示收到了有效的数据包，开始检查数据包的正确性

		// 记录的数据+=1
		RecvNumInThisTurn += 1;

		// 计算回来的序号
		unsigned int answerNum;
		answerNum = unsigned short int(recvBuf[1]) & 0xFF;
		answerNum = (answerNum << 8) + (unsigned short int(recvBuf[2]) & 0xFF);
		answerNum = (answerNum << 8) + (unsigned short int(recvBuf[3]) & 0xFF);
		cout << "FROM S:\nchecksum: " << int(recvBuf[0]) << "\tack: " << answerNum << "\n";
		
		//if (curr <= lastAck)//本不必要，但是由于多线程的curr会乱，所以多加一个判断
		//	curr = lastAck + 1;
		// 检查checksum和是不是应该收到的包
		if ((newGetChecksum(recvBuf, 4) == 0)) {
			cout << "需要发送curr: " << curr << "\t已收到lastAck: " << lastAck << "\t刚收到answerNum" << answerNum << "\tmaxAckTimes: " << maxAckTimes << "\n";
			if (answerNum == (lastAck + 1)) {
				// 此时表示收到的包是正确的
				// 设置记录位
				WaitForSingleObject(hMutex, INFINITE);
				lastAck += 1;
				ReleaseMutex(hMutex);
				sameAckTimes = 1;
				maxAckTimes = 1;

				// 判断计时器是否停止计时
				if (lastAck == (totalNum - 1))
					timer = -1;
			}
			else if (answerNum == lastAck) {
				// 记录的次数+1
				sameAckTimes += 1;
				maxAckTimes++;
				//curr = lastAck + 1;
				// 判断是否到达3次，如果到达了3次就进行快速重传
				if (sameAckTimes == 3) {
					cout << "重复ACK次数达到3次，进行重传，并进入到快恢复阶段\n";
					
					//// 重传server需要的（也就是丢了的包）
					//sendto(sendSocket, (char*)sendPackage[lastAck + 1], 1024, 0, (SOCKADDR*)&serverAddr, socketAddrLen);
					//cout << "当前发送数据包为：\nseq: " << curr << "\nlen高: " << int(sendPackage[curr][4]) << "\tlen低: " << int(sendPackage[curr][5])
					//	<< "\tchecksum: " << int(sendPackage[curr][0]) << "\n" << "ssthresh：" << ssthresh << "\tcwnd：" << cwnd << "\n";

					// 首先需要把来自server的剩余的那些answer给收掉
					//cout << "接收剩下的ans，当前状态为：\ncwnd: " << cwnd << "\tnumber: " << RecvNumInThisTurn << "\n";
					//while (RecvNumInThisTurn<cwnd)
					//{
					//	while (recvfrom(sendSocket, recvBuf, 4, 0, (SOCKADDR*)&serverAddr, &socketAddrLen) == SOCKET_ERROR) {

					//	}
					//	RecvNumInThisTurn += 1;
					//	cout<<"cwnd: " << cwnd << "\tnumber : " << RecvNumInThisTurn << "\n";
					//}

					// 进入到快恢复
					ssthresh = max(cwnd / 2, 2);
					cwnd = ssthresh + 3;
					WaitForSingleObject(hMutex, INFINITE);
					curr = lastAck + 1;
					ReleaseMutex(hMutex);
					sameAckTimes = 0;
					// cout << "cwnd: " << cwnd << "\n";
				}
				continue;
			}
			else if (answerNum > lastAck)
			{
				lastAck = answerNum;
				//curr = lastAck + 1;
			}
			else {
				// answerNum < lastAck的情况，一般不会出现
				return;
			}
		}
		else {
			// 要么是收到的包错了，重传一下之前的部分
			cout << "==================收到的数据包有误，将刚刚的全部重传:\n";
			int tempCal = 0;
			for (tempCal; (tempCal < cwnd) && (curr < totalNum); tempCal++) {
				// 发送数据包
				sendto(sendSocket, (char*)sendPackage[curr], 1024, 0, (SOCKADDR*)&serverAddr, socketAddrLen);
				if (tempCal == (cwnd - 1) || curr == (totalNum - 1))
					// 计时器开始计时
					timer = clock();
				// 输出相关信息
				cout << "当前发送数据包为：\nseq: " << curr << "\nlen高: " << int(sendPackage[curr][4]) << "\tlen低: " << int(sendPackage[curr][5])
					<< "\tchecksum: " << int(sendPackage[curr][0]) << "\n" << "ssthresh：" << ssthresh << "\tcwnd：" << cwnd << "\n";
				curr += 1;
			}
			//重新开始计时
			timer = clock();
		}
	}

	sendFileTime = clock() - sendFileTime;
	// 计算成秒
	sendFileTime = sendFileTime / CLOCKS_PER_SEC;
	cout << "本次传输所用时间为：" << sendFileTime << " s." << "\n";
	// 计算吞吐率
	Throughput = fileLen / sendFileTime;
}

/// <summary>
/// 挥手使用的函数，这里使用的是停等机制
/// </summary>
static void sayGoodBye2Server() {
	// 两次挥手，断开连接

	// 数据包：check, SYN，FIN，SHAKE/WAVE
	char shakeChar[4];
	shakeChar[1] = 0x00;
	shakeChar[2] = 0x01;
	shakeChar[3] = WAVE1;
	shakeChar[0] = newGetChecksum(shakeChar+1, 4-1);
	// 发送WAVE1
	sendto(sendSocket, shakeChar, 4, 0, (SOCKADDR*)&serverAddr, socketAddrLen);
	cout << "断开连接，发送数据包为（第一次挥手）：\n";
	cout << "SYN: " << int(shakeChar[1]) << "\tFIN: " << int(shakeChar[2]) << "\tSHAKE: " << int(shakeChar[3]) << "\tcheckSum: " << int(shakeChar[0]) << "\n";
	
	// 开始计时
	int beginTime = clock();

	// 停等，等服务器的挥手
	char recvWaveBuf[4];
	while (true) {
		while ((recvfrom(sendSocket, recvWaveBuf, 4, 0, (SOCKADDR*)&serverAddr, &socketAddrLen))==SOCKET_ERROR) {
			if (clock() - beginTime > MAX_WAIT_TIME) {
				cout << "超过最长等待时间，重传:";
				sendto(sendSocket, shakeChar, 4, 0, (SOCKADDR*)&serverAddr, socketAddrLen);
				beginTime = clock();
				cout << "SYN: " << int(shakeChar[1]) << "\tFIN: " << int(shakeChar[2]) << "\tSHAKE: " << int(shakeChar[3]) << "\tcheckSum: " << int(shakeChar[0]) << "\n";
			}
		}
		if (newGetChecksum(recvWaveBuf, 4)==0 && recvWaveBuf[1] == 0x00 && recvWaveBuf[2] == 0x01 && recvWaveBuf[3] == WAVE2) {
			// 收到握手包正确
			cout << "收到来自服务器的第二次挥手：\n";
			cout << "SYN: " << int(recvWaveBuf[1]) << "\tFIN: " << int(recvWaveBuf[2]) << "\tSHAKE: " << int(recvWaveBuf[3]) << "\tcheckSum: " << int(recvWaveBuf[0]) << "\n";
			memset(recvWaveBuf, 0, 4);
			memset(shakeChar, 0, 4);
			break;
		}
		else {
			cout << "服务器挥手失败，重传挥手数据包\n";
			sendto(sendSocket, shakeChar, 4, 0, (SOCKADDR*)&serverAddr, socketAddrLen);
			cout << "断开连接，发送数据包为（第一次挥手）：\n";
			cout << "SYN: " << int(shakeChar[1]) << "\tFIN: " << int(shakeChar[2]) << "\tSHAKE: " << int(shakeChar[3]) << "\tcheckSum: " << int(shakeChar[0]) << "\n";
		}
	}
}

/// <summary>
/// main
/// </summary>
/// <returns></returns>
int sendMain() {
	// 获取socket库，开始网络编程
	WSADATA wsadata;
	if (WSAStartup(MAKEWORD(2, 2), &wsadata)) {
		//如果加载出错，暂停服务，输出出错信息
		cout << "载入socket失败\n";
		return -1;
	}
	
	// 对sendSocket进行相关设置
	sendSocket = socket(AF_INET, SOCK_DGRAM, 0);
	if (sendSocket == INVALID_SOCKET) {
		cout << "socket创建失败\n";
		return -1;
	}
	
	// 将服务器的套接字和ip、port绑定
	serverAddr.sin_family = AF_INET;
	// ************需要输入的是服务器（也就是要发送的意定方）的IP
	char IP[16];
	cout << "输入要发送的服务器（server）的IP：\n";
	getIP(IP);
	inet_pton(AF_INET, IP, &serverAddr.sin_addr.s_addr);
	// serverAddr.sin_port = htons(SERVER_PORT);
	// 改为发到路由器
	serverAddr.sin_port = htons(LUYOU_PORT);

	// 对自己的进行处理
	clientAddr.sin_family = AF_INET;
	// ************输入自己（client）的IP
	cout << "输入客户端（自己）的IP：\n";
	getIP(IP);
	inet_pton(AF_INET, IP, &clientAddr.sin_addr.s_addr);
	clientAddr.sin_port = htons(CLIENT_PORT);

	// 对recvSocket进行处理
	recvSocket = socket(AF_INET, SOCK_DGRAM, 0);

	// 设置超时的时间
	setsockopt(recvSocket, SOL_SOCKET, SO_RCVTIMEO, (char*)&MAX_WAIT_TIME, sizeof(MAX_WAIT_TIME));

	int isBind = bind(recvSocket, (SOCKADDR*)&clientAddr, sizeof(clientAddr));
	// 判断是否绑定成功
	if (isBind == SOCKET_ERROR) {
		cout << "客户端的recvSocket绑定失败，错误代码为：" << WSAGetLastError();
		closesocket(recvSocket);
		WSACleanup();
		return -1;
	}

	// 和server建立连接
	connet2Server();
	
	// 显示文件列表
	getFileList();

	// 获取要发送的文件名
	cout << "输入想要传输的文件名：";
	char tempName[20];
	cin.getline(tempName, 20);

	// 计算文件名的长度
	unsigned short int fileNameLen = 0;
	while (tempName[fileNameLen] != '\0')
		fileNameLen += 1;

	// 发送文件
	sendFile2Server(tempName, fileNameLen);

	Sleep(600);

	// 四次挥手
	sayGoodBye2Server();
	
	// 输出吞吐率
	cout << "本次传输吞吐率为：" << Throughput << " Kb/s" << "\n";

	return 0;
}